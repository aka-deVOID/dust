#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_explicit_arithmetic_types : require

struct Block
{
    u16vec4 position;
    uint64_t mask;
    uint32_t material_ptr;
    uint32_t reserved;
};

layout(buffer_reference, buffer_reference_align = 8, std430) buffer GeometryInfo {
    Block blocks[];
};

layout(shaderRecordEXT) buffer sbt {
    GeometryInfo geometryInfo;
    uint64_t materialInfo;
    uint64_t paletteInfo;
};

vec2 intersectAABB(vec3 origin, vec3 dir, vec3 box_min, vec3 box_max) {
    vec3 tMin = (box_min - origin) / dir;
    vec3 tMax = (box_max - origin) / dir;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float t_min = max(max(t1.x, t1.y), t1.z);
    float t_max = min(min(t2.x, t2.y), t2.z);
    return vec2(t_min, t_max);
}

vec3 CubedNormalize(vec3 dir) {
    vec3 dir_abs = abs(dir);
    float max_element = max(dir_abs.x, max(dir_abs.y, dir_abs.z));
    return -sign(dir) * step(max_element, dir_abs);
}

void main()
{
    Block block = geometryInfo.blocks[gl_PrimitiveID];

    vec2 initialIntersectionT = intersectAABB(
        gl_ObjectRayOriginEXT - block.position.xyz, // origin
        gl_ObjectRayDirectionEXT,
        vec3(0.0, 0.0, 0.0),
        vec3(4.0, 4.0, 4.0)
    );
    if (initialIntersectionT.x >= initialIntersectionT.y) {
        return;
    }

    reportIntersectionEXT(initialIntersectionT.x, 0);
}
