#version 460
#include "standard.glsl"

layout(shaderRecordEXT) buffer Sbt {
    vec3 camera_view_col0;
    float near;
    vec3 camera_view_col1;
    float far;
    vec3 camera_view_col2;
    float _padding;
    vec3 camera_position;
    float tan_half_fov;
} sbt;
layout(location = 0) rayPayloadEXT struct RayPayload {
    f16vec3 illuminance;
} payload;


void main() {
    float hitT = imageLoad(u_depth, ivec2(gl_LaunchIDEXT.xy)).x;
    if (hitT == 0.0) {
        // Did not hit.
        return;
    }
    payload.illuminance = f16vec3(imageLoad(u_illuminance, ivec2(gl_LaunchIDEXT.xy)).xyz);

    const vec2 pixelNDC = (vec2(gl_LaunchIDEXT.xy) + vec2(0.5)) / vec2(gl_LaunchSizeEXT.xy);

    vec2 pixelCamera = 2 * pixelNDC - 1;
    pixelCamera.y *= -1;
    pixelCamera.x *= float(gl_LaunchSizeEXT.x) / float(gl_LaunchSizeEXT.y);
    pixelCamera *= sbt.tan_half_fov;

    const mat3 rotationMatrix = mat3(sbt.camera_view_col0, sbt.camera_view_col1, sbt.camera_view_col2);
       
    const vec3 rayWorldDir = rotationMatrix * vec3(pixelCamera, -1);

    const vec3 normalWorld = imageLoad(u_normal, ivec2(gl_LaunchIDEXT.xy)).xyz;
    vec3 hitLocation = hitT * rayWorldDir + sbt.camera_position + normalWorld * 0.01;

    vec3 noiseSample = texelFetch(blue_noise, ivec2((gl_LaunchIDEXT.xy + uvec2(7, 183) + pushConstants.rand) % textureSize(blue_noise, 0)), 0).xyz;
    // noiseSample is weighted on the z axis
    noiseSample = noiseSample * 2.0 - 1.0;

    const vec3 k = cross(vec3(0, 0, 1), normalWorld);
    const float cosTheta = dot(vec3(0, 0, 1), normalWorld);
    const float sinTheta = length(k);
    const vec3 crossed = cross(k, noiseSample);
    vec3 rotatedNoiseSample = noiseSample * cosTheta + crossed * sinTheta + k * dot(k, noiseSample) * (1.0 - cosTheta);

    if (dot(rotatedNoiseSample, vec3(normalWorld)) < 0.0) {
        rotatedNoiseSample = -rotatedNoiseSample;
    }

    // Shoot shadow ray
    traceRayEXT(
        accelerationStructure,
        gl_RayFlagsOpaqueEXT, // RayFlags
        0xFF, // CullMask
        3, // SBT offset, ray type index // Use the same intersection shader. We need higher-quality intersection for shadow rays as well.
        4, // SBT stride, number of ray types // TODO: Make this a shader constant
        2, // missIndex
        hitLocation,     // ray origin
        sbt.near,           // ray min range. If we set this to 0.0, VK_DEVICE_LOST. Time stuck: 2 days
        rotatedNoiseSample, // direction
        sbt.far, // tmax
        0 // payload
    );
}
