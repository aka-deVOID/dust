#version 460
#extension GL_EXT_ray_tracing : require

layout(set = 0, binding = 2) uniform accelerationStructureEXT accelerationStructure;

layout(shaderRecordEXT) buffer Sbt {
    vec3 camera_view_col0;
    float near;
    vec3 camera_view_col1;
    float far;
    vec3 camera_view_col2;
    float _padding;
    vec3 camera_position;
    float tan_half_fov;
} sbt;
layout(location = 0) rayPayloadEXT vec3 hitLocation;


void main() {
    const vec2 pixelNDC = (vec2(gl_LaunchIDEXT.xy) + vec2(0.5)) / vec2(gl_LaunchSizeEXT.xy);

    vec2 pixelCamera = 2 * pixelNDC - 1;
    pixelCamera.y *= -1;
    pixelCamera.x *= float(gl_LaunchSizeEXT.x) / float(gl_LaunchSizeEXT.y);
    pixelCamera *= sbt.tan_half_fov;

    const mat3 rotationMatrix = mat3(sbt.camera_view_col0, sbt.camera_view_col1, sbt.camera_view_col2);

    const vec3 pixelCameraWorld = rotationMatrix * vec3(pixelCamera, -1);
    hitLocation = vec3(0.0);
    traceRayEXT(
        accelerationStructure,
        gl_RayFlagsOpaqueEXT , // RayFlags
        0xFF, // CullMask
        0, // SBT offset, ray type index
        2, // SBT stride, number of ray types
        0, // missIndex
        sbt.camera_position,     // ray origin
        sbt.near,           // ray min range
        pixelCameraWorld, // direction
        sbt.far, // tmax
        0 // payload
    );
    if (hitLocation.x == 0.0) {
        return;
    }

    const vec3 sunDir = vec3(0.0, 0.80114365, -0.5984721);
    // Shoot shadow ray
    traceRayEXT(
        accelerationStructure,
        gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT, // RayFlags
        0xFF, // CullMask
        0, // SBT offset, ray type index // Use the same intersection shader. We need higher-quality intersection for shadow rays as well.
        2, // SBT stride, number of ray types
        1, // missIndex
        hitLocation,     // ray origin
        0.0,           // ray min range
        sunDir, // direction
        sbt.far, // tmax
        0 // payload
    );
}
